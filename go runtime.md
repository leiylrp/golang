# Golang Runtime设计

​	从开始学习Go语言开始，就是通过先学习基础语法，再通过进阶的深入学习Go的数据结构：slice、map、channel等的使用和场景，同时伴随着反射、并发编程和网络编程的学习，从而掌握Go语言的基础开发。这是一种在语言层面的分模块的学习，适合刚接触Go的小伙伴的学习。最近通过Go夜读重新学习了Go语言，有所感想和启发，在这里分享一些所思所想。

​	从Runtime的角度来看Go，包括Go调度和内存管理，其中Go调度包括GMP模型、goroutine网络调用产生的调度、goroutine系统调用产生的调度以及goroutine加锁产生的系统调用，内存管理包括Go的内存分配和GC。见下图所示：

![概览](https://github.com/leiylrp/golang/blob/main/images/goruntime/%E6%A6%82%E8%A7%88.jpg)

接下来就将从Go调度来理解Golang Runtime。为了更好的理解Golang Runtime，理解操作系统中的进程管理和内存管理以及必要的网络编程知识我觉得是必要的。

## 一、操作系统与网络编程

用户使用计算机，就是启动了一堆的进程，用户管理计算机就是管理一堆的进程，这是操作系统最核心的，最复杂的灵魂。

### 1、操作系统——进程管理

​	Go的调度设计到操作系统，这里就需要先理解操作系统当中的进程和线程以及协程。在计算机中的软件都是跑在操作系统之上，任何一个应用程序在没有执行起来之前的数据都是保存在磁盘中，当程序运行时会将应用程序数据加载到内存，通过CPU来取址执行。

​	这里我们拿单核CPU理解。

​	单进程/单线程时代，如果系统启动了多个应用程序：程序A、程序B、程序C和程序D，将各个程序加载到内存中我们可以把它们看作是进程A、进程B、进程C和进程D，由于进程的执行需要靠CPU在内存中对进程的取指令才能执行，所以在单核CPU中，就会出现CPU执行完进程A才会执行进程B、进程C和进程D：进程A -> 进程B -> 进程C -> 进程D。如果进程A、进程B中都会出现磁盘读写的情况导致进程阻塞，就会让整个进程执行时间增加，导致后续进程执行时间也增加。整体的效率就会很差。

​	那么如果我们在进程A进行磁盘读写时，将进程切到进程B去执行，等进程A磁盘读写完成时，再通过合适的时间切回来是不是就能解决上面面临的问题呢？是的。

​	这样就进入多进程/多线程时代，同样在单核CPU中，当CPU执行进程A出现磁盘读写时，进程A会阻塞，那么CPU就会切换到进程B执行，这样就会大大缩短了执行时间，进程A在系统调用的同时，CPU还能去执行进程B。通过下面的图来理解会更清晰。

![多线程](.\images\goruntime\多线程.jpg)

​	在图中我们可以看到，多线程模型中，单核CPU在同一时刻只能执行一个进程，没有办法同一时刻执行多个进程，这个就是操作系统中的并发模型：多个进程在同一时刻，交替执行。如果我们在一个双核CPU中，两个CPU同时执行一个进程，这个就是操作系统中的并行。

​	通过上面的我们就可以理解单进程/单线程和多进程/多线程。那么接下来应该会有疑惑：什么是进程、什么是线程呢？

​	进程在操作系统层面就是一个PCB：Process Control Block（进程控制块），用来记录进程信息的数据结构，操作系统感知进程就是PCB，PCB记录了许多东西，包括资源+指令的执行序列。所以进程是一个包含指令序列的执行程序和一个拥有一组资源（内存、IO、系统资源）的实体

​	操作系统管理进程就是在多个PCB建立数据结构。有些PCB处于运行态，有些PCB会处于就绪态，有些则处于等待态。所以操作系统管理进程，就是将多个进程的PCB放在不同的队列中。所以通过PCB+状态+队列就是操作系统对多个进程的组织。

![进程状态图](.\images\goruntime\进程状态图.jpg)

​	回到：进程=资源+指令序列，这个资源就包括内存。结合多进程模型来看，单核CPU执行进程A，进程A需要进行系统调用了，CPU就切换到进程B，在这个切换的过程中就需要切换映射表(内存)和指令序列，代价比较大。那么我们可以将资源和指令序列分开，能够实现一个资源+多个指令的执行序列，就能更大化的减少开销。

​	**进程** 是操作系统资源分配的基本单位，包含了指令执行序列和所需的资源（如内存、文件、I/O 设备等），**线程** 是进程内部的 **执行单元**。一个进程可以有多个线程，所有线程共享进程的资源，但每个线程都有自己的执行路径（例如程序计数器、寄存器、堆栈），可以把进程看作是一个 **容器**，而线程是这个容器中的 **工作者**。每个线程都是在同一个进程内运行，但它们执行各自的指令。

​	线程可以细分为用户态线程和内核级线程，一段代码需要进行系统调用就必须通过中断进入内核，进行磁盘读写时由操作系统的调度器调度内核级线程。其中用户态线程在用户态进行切换调度，是基于抢占式的调度，这里就引申出Go中的协程，基于协作式调度，在Go 1.1x 的版本中增加了抢占式调度。

​	所以需要明确 进程、线程（用户态线程、内核级线程）和协程 在操作系统中的关系和原理。为后续理解Go中的Goroutine坐下铺垫。

![进程线程协程](.\images\goruntime\进程线程协程.jpg)

### 1、GMP模型

​	G：goroutine协程，M：thread线程，P：processor处理器。

​	

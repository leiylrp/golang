
一、MySQL高级调优

1、MySQL的一条语句是如何执行的？
Client -> MySQL Server -> Innodb存储引擎

（1）MySQL Server（连接池、分析器、优化器和执行器）
（2）Innodb存储引擎
    事务和锁，以及redo log，undo log和bin log保证数据最终一致性
    通过索引和全表扫描进行定位到具体的行进行数据最终一致性的操作。
这里主要理解redo log和bin log的二阶段提交。

2、如何理解MySQL的执行计划？
explain去查看，重要的字段有key和type。
通过key可以知道我们是否走索引以及走的哪个索引
type字段有从优到差分别是：const > eq_ref > ref > index_merge ~ range > index > ALL。一般要求我们的SQL都要走到range。

3、MySQL索引下推你了解多少？
早期的MySQL版本中，在对非主键索引进行查找或者范围查找时，如果SQL的查询条件有两个以上并且查询条件都在非主键索引，这个时候存储引擎无感知，而是会回表拿到全量数据再对剩余条件进行匹配，这就是在非主键索引时的一个性能瓶颈，然后根据这个性能瓶颈进行优化，在非主键索引上进行匹配，把不匹配的数据过滤，拿到匹配的数据进行回表返回数据。这个过程就是index condition pushdown，也叫做索引下推。

4、MySQL调优

一条SQL很慢，你如何去排查问题和调优？
MySQL性能监控和慢查询日志

然后通过explain结合key和type分析。

本质上一条SQL很慢，可能的主要原因有四个：根本就没有索引字段，有索引字段但是优化器认为全表扫描更快，有索引字段但是优化器选择了不合适的索引以及走了正确的索引还是很慢。下面我从这四个主要原因具体分析。您看下可以吗？

（1）没有索引字段：就是你的SQL根本就没有索引的查询条件，自然没有走索引，表数据量很大就会很慢，这是很正常的。
（2）有索引字段但是因为某些操作导致索引失效：
    OR操作：单表中有一个不是索引字段会导致索引失效，多表不管是不是索引直接失效。
    对索引字段进行表达式计算导致索引失效。
    LIKE操作进行前缀模糊匹配导致索引失效。
    对表字段进行了隐式转换导致索引失效。
    联合索引不符合最左前缀
（3）有索引字段但是优化器认为不走索引更快：这个是优化器层面的，官网的描述如果查询范围大于30%以及结合MySQL自身的CPU IO和网络等可能就会进入全表扫描，这个时候可以进行强制走索引去分析或者通过修改全局变量限制范围。
（4）走了索引但是优化器选择了不合适的索引：比如像一些order by的联合查询，他可能会因为考虑到文件排序的原因而选择不合适的索引，这个时候也是同样的，可以进行强制它走正确的索引，这是一种优化方案。如果两个字段联合使用的场景比较多，可以添加为联合索引，这也是一种优化方案。如果数据量大涉及到分页，联合索引或者说是非主键索引都会面临的一个问题就是深分页的问题，本质上就是因为MySQL Server和Innodb存储引擎层的执行条件不一致导致不符合页数的的每一次查询都要进行回表这些都是无用操作，这个时候可以使用覆盖索引减少回表次数。这也是一种优化方案。
（5）走了正确的索引但还是很慢。通过explain分析，key有值就算但是type走的是index。这个虽然是走了索引，比全表扫描快都是很有限，本质上也差不多算是全表扫描。可能的原因是SQL符合覆盖索引但是不符合最左前缀匹配，这个时候就需要修改SQL让他符合最左前缀或者创建合适的索引。还有可能的原因是MySQL自身的问题，可能是连接数耗尽，或者MySQL网络，IO，CPU都很高也可能。还有可能是在Innodb在高并发场景下，由于事务和锁的一些场景导致阻塞变慢或者死锁等待。以及首次查询没有命中缓存也会导致很慢。


5、你刚刚说到，由于事务和锁的一些特殊场景导致阻塞变慢或者死锁，你能说说具体哪些特殊场景吗？
（1）首先被阻塞变慢的场景：
    ① 针对主键索引或者唯一索引：锁的单位是临键锁，当某个事务对行记录加了记录锁，或者加了间隙锁，在该事务没有提交之前，其他事务都无法对行记录进行当前读或者更新操作，此时就会被阻塞。如果是范围的当前读，会对索引扫描到的主键加上next-key lock，某些情况下会退化成记录所或者间隙锁，其他事务在范围内均不能当前读和更新。
    ② 针对非唯一索引：由于非唯一索引可能会存在多个，并且索引相同时，按照主键id进行排序。如果非唯一索引被锁住了，并且id范围内也被锁住。其他事务在非唯一索引并且主键范围内也会被锁住，如果事务在相同的非唯一索引但是主键索引不在锁住范围内，则不会被阻塞。
    ③ 没有命中索引：会进行全表扫描，扫描到的每每一行都会被加入next-key lock，导致其他事务对表内的任何当前读和更新都被阻塞。
（2）死锁等待场景：
    ① 两个事务都要对某个区间内的记录进行修改，如果记录不存在则添加记录。T1更新记录时发现记录不存在，给区间加上间隙锁，T2更新记录发现自己的记录也不存在，加上记录所。紧接着T1给区间内插入自己的数据就会被阻塞，T2又往区间内插入自己的数据于是形成死锁。如果开启了死锁检测T1就会执行成功T2语句执行失败。这是由于间隙锁+插入意向锁不兼容导致死锁。
    ② 两个事务插入相同行，T1事务插入数据加入了插入意向锁，而此刻T2再插入相同的数据时，发现有插入意向锁，那么自己的排他锁就加入不成功了，会持有该行的共享锁。为了保证T1事务回滚T2能准确插入数据。这个是没毛病的。但是如果这个时候再来一个T3插入相同的主键数据，也会因为相同原因被阻塞。这个时候T1回滚，就会导致T2和T3都持有该行的共享锁导致死锁，将只有一个事务能执行成功。



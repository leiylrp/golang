# RPC设计与实现
## 1.RPC实现原理
RPC定义：远程过程调用，是一种定义，通过反射机制和内部调用网络io向调用者屏蔽了处理复杂网络数据传输的功能，比如组包解包，数据发送和接收。同时对于服务消费者提供连接管理，负载均衡，请求路由，超时处理和健康检查等核心功能，对于服务提供者提供队列/线程池，超时处理机制，优雅关闭和过载保护等核心功能，整体提供更为高级的服务熔断，服务降级，动态权重，限流成为一个完整的RPC产品。业内用的最多的RPC产品是gRPC和Dubbo。

RPC的核心组成：
    （1）远程方法对象代理
    （2）连接管理
    （3）序列化和反序列化
    （4）寻址和负载均衡

    ![p1](https://github.com/leiylrp/golang/blob/main/images/project/micro/micro/p2.png)
### 1.1 代理与远程代理如何实现？
核心：
    （1）客户端如何通过反射拿到对应的结构体字段的参数以及字段，并修改结构体字段为网络调用函数？
        构造闭包函数，在运行时将闭包函数设置为要调用的方法。
        通过reflect.MakeFunc构造闭包函数，内部通过反射拿到参数构造请求，包括服务名。序列化，请求路由，负载均衡，拿到连接，发送数据。

    （2）服务端如何根据拿到的数据，找到对应的服务和方法进行本地调用？
        服务端通过网络编程：net.Listen和listener.Accept拿到连接的请求数据，进行反序列化,找到服务端注册的服务，通过反射Call进行本地方法调用。

### 1.2 序列化和反序列化如何实现？

要点：
    （1）TCP协议：流式，分片，拥塞控制，滑动窗口
    （2）网络编程与Go实现细节：大端序和小端序，IO多路复用，粘包和半包
    （3）原生数据JSON编码实现

核心：
    （1）TCP粘包和半包问题如何解决？
        TCP的流式协议，所以消息没有边界，如果基于网络原生开发，需要特别注意大端序和小端序以及将请求包封装成请求头和请求体。请求头里带有请求数据的大小。经过封装，如果数据太大，TCP会对数据包进行分片。服务端在通过IO多路复用拿到连接获取到数据包，每个数据包都带有TCP分片之后的数据包标识以及我们在客户端封装的请求头和请求数据，我们从请求头读到数据，根据请求头数据拿到请求体数据。
    （2）序列化和反序列化做了什么？
        编写proto文件，通过命令protoc进行生成对应的go pb文件，比如service对应一个服务，message对应的go中的struct，并根据protobuf协议生成相应的序列化和反序列化方法。
    （3）大端序和小端序如何选择？
    （4）如何校验数据包的完整性？

    （5）字符串转整数底层如何实现？

### 1.3 网络模块数据如何传输？
核心：
    （1）TCP长连接的建立与释放？
        三次握手四次挥手
    （2）数据在网络中如何进行路由和寻址？


## 2.RPC服务消费方核心功能实现

### 2.1 连接管理 
![p3](https://github.com/leiylrp/golang/blob/main/images/project/micro/micro/p3.png)
保持与服务提供方的长连接，用于传输数据和返回结果。预先分配连接、连接池。
核心：
    （1）初始化时机？网关和业务模块如何初始化？
        在服务进行启动时，就需要对连接进行初始化。在实际的微服务业务场景中，如果网关与许多服务都有数据交互，一般不会初始化连接，而服务和服务之间需要初始化连接，这里就会有需要我们思考的问题，服务如何维护连接数的问题，拿到连接之后如何工作以及数据回来如何配对请求数据和唤醒线程的问题。
    （2）连接数如何维护？
        设计一个连接池，需要调用时从连接池获取连接，调用完毕放回连接池。
    （3）如何建立与多个服务之间的连接池？
        懒加载的方式建立连接，通过连接进行数据交换之后，将连接放入连接池，连接池默认100个连接。连接也有存活时间，默认是1分钟，如果一分钟没有使用，将会失效。
    
    （3）数据库获取链接时为什么会出现无连接可用的错误？
    （4）工作线程和IO线程如何工作的？
        工作线程只负责
    （5）数据回来如何配对发送的数据？requestSessionId。 如何唤醒工作线程？



### 2.2 负载均衡 
![p4](https://github.com/leiylrp/golang/blob/main/images/project/micro/micro/p4.png)
确保多个服务提供方节点流量均匀合理，支持节点扩容与灰度发布。
负载均衡策略：轮询、随机、取模、带权重、一致性hash
核心： 
    （1）go-micro的selector如何实现？
        客户端是否有指定要选择调用的服务列表，如果有，则通过time.Now().Unix() % int64(len(nodes))获取随机的服务节点连接进行调用。如果没有，先从本地缓存中获取服务，本地缓存无服务则去注册中心获取服务,然后通过随机选择一个服务去调用。
        更加高级的可以通过权重负载均衡实现。
    （1）权重负载均衡如何实现？随机数组和随机值？
        可以通过权重

### 2.3 请求路由 
![p5](https://github.com/leiylrp/golang/blob/main/images/project/micro/micro/p5.png)
通过一系列规则过滤出可以选择的服务提供方节点列表，在应用隔离，读写分离，灰度发布中都发挥作用。
流量规则路由，某些流量策略只能发送到某几个节点

核心：
    （1）路由规则如何设计？Dubbo如何做灰度流量？
    （2）如何判断一个流量是灰度流量？RPC隐式参数上下文里面有灰度标签，每个框架有不同的实现。
### 2.4 超时处理 p6
    客户端超时机制：客户端发出数据之后， 在发出数据时会构造一个添加一个类似SessionId-WindowData的数据（请求，线程），线程以及运行在线程的协程会跟P分离，线程进入阻塞状态，超时时间默认5s，如果超时就丢弃数据，重新被唤醒绑定到新的P。


核心：
（1）发出去的数据，如果请求一直没有回来，如何处理？工作线程和IO线程，超时逻辑，数据结构。

### 2.5 健康检查
    ping-pong就可以了，如果服务下线或者重启，只需要标记为服务不可用即可。以便于服务上线之后能快速更新服务状态。

## 3.RPC服务提供方核心功能实现

### 3.1 队列/线程池
将不同类型的请求，放入各自的队列，每个队列分配独立的线程池，进行资源隔离。
核心：
    （1）


### 3.2 超时处理
核心：
（1）队列的数据处理不过来，如何处理？
        - 超时丢弃
        - 增加线程数量
（2）过载保护：服务提供方为保证正常运行，主动丢弃超出处理能力外的请求

### 3.3 优雅关闭
核心：
（1）服务重启，如何保证流量不被丢弃？
        - kill -9 和 kill -12
        - 如何保证优雅关闭？优雅关闭客户端和服务端。
            ① 处理每个请求都加入过滤器
            ② 通知客户端不发请求
                返回数据中带关闭信息
                专门关闭协议通知调用方
